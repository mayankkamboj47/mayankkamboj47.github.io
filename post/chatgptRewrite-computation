String substitution can be used to create a computation model that is as powerful as Turing machines. This model uses a smaller set of basic operations, and programs written in it are easier for humans to understand.

The Model

The model starts with a set S that contains an infinite number of symbols. These symbols are used to create input and output strings, as well as intermediate strings that result from applying transformations to the input. The use of an infinite symbol set becomes clear as we progress. Within this symbol set, we have the symbols "1" and "0".

The input is a string consisting of sequences of 1s separated by 0s. Each sequence represents a number equal to the count of 1s in that sequence. For example, the input "5, 4" would be represented as "1111101111". The output is a continuous string of 1s, with a count equal to the desired number.

For instance, a program that doubles the given number would produce "1111" for the input "11". Similarly, a program that multiplies two numbers would generate "111111" for the input "110111" (which represents 2,3).

To manipulate the input string, we have an operation called "sub" that allows us to substitute a specific substring with another substring. For example, applying the line "sub 1 ðŸ’™" to the string "111" would result in the output "ðŸ’™ðŸ’™ðŸ’™."

Here is a brief program that doubles any given input:

sub 1 ðŸ’™
sub ðŸ’™ 11

Alternatively, we can write it as shorthand:

sub 1 11

assuming that all instances of 1 are replaced with 11 simultaneously.

Finally, the special symbols $ and ^ represent the start and end of a string. For example, "sub 1$ 0" replaces the 1 at the end of the string with a 0. If the string does not end with 1, it does not match. Similarly, "sub ^hi hello" matches only the starting "hi" in a string. If the input string is "hi hiroshi," it matches only the starting "hi" and not the "hi" in "hiroshi." If the string does not start with "hi," it does not match.

Turing Completeness

Can we perform every calculation possible with this model of computation? This is a difficult question to answer because it is challenging to formalize the concept of every possible calculation. A slightly easier question is whether it can perform every operation that a modern computer with infinite memory and computing power can do. The answer is YES. We can prove this by demonstrating that we can simulate Turing machines, which are the most powerful model of computation known, using our model.

A Turing machine consists of a tape with blocks, each containing a 1 or a 0, similar to the input of our computation model. It produces output in a similar way to our model. There are significant differences in the processes used by Turing machines and our model to arrive at the final answer. Another minor difference is that Turing machines start with an infinite tape, while our model starts with finite space. However, we can add additional storage by using the "sub $ 000" command, which appends three 0s at the end.

Turing machines also have a head that can perform four operations: move right, move left, write a 1, and write a 0. The instructions have the following format: In state X, if at <1 or 0>, and go to state Y.

We can simulate these instructions in the substitution model. To represent the head, we use

 a set of symbols for different states. For each state, we have two symbols: one for "head at 1" and another for "head at 0".

At the beginning of the computation, we can introduce the head with the following short program:

sub 1$ ðŸ’™
sub 0$ âœ…

Here, ðŸ’™ represents the head in state 0 at bit 1, and âœ… represents the head in state 0 at bit 0. To add more states, we add more symbols, two per state: one for 1 and another for 0.

As mentioned earlier, Turing machines perform operations at each step based on quadruples that match the current state. We have only translated the quadruples so far, but we still need a way to cycle through them and stop when no match is found. We can make this cycling either implicit, as in Turing machines, or explicit by introducing a "repeat till no change" operator:

repeat till no change:
    <translated quadruples here>

We only need this "repeat till no change" operator once in the entire program to cycle through the translated quadruples. This completes the proof of equivalence to Turing machines. Here is a translation of a simple code that adds a 1 at the start of the input:

replace 1$ ðŸ’™                   # introduces the head at the right end
repeat till no change:         # translated quadruples begin here:
    replace 1ðŸ’™ ðŸ’™1
    replace ^ðŸ’™ âœ…1              # a01La0
    replace âœ… ðŸ”¥                # a001a1
replace ðŸ”¥ 1                    # some closing code to ensure only 1 and 0 remain

With this example, we conclude the section on Turing completeness. Direct translation is not always optimal. For example, to prepend 1, the optimal way is the one-liner "sub ^ 1," where we take advantage of the fact that "^" alone matches the start of the string without consuming any characters, effectively meaning "prepend x."

The Joy of Substitution

Operations in the substitution model are intuitive and often concise. For example, adding a constant, such as 5, is simply "sub $ 11111," compared to the complexity of quadruples in Turing machines, where the number of quadruples increases with the size of the constant. Similarly, multiplication with constants is intuitive: "sub 1 111" multiplies by 3. By mapping each 1 to 111, we triple the total count of 1s. If substituting "all at once" seems like cheating, you may still appreciate the equivalent program:

sub 1 ðŸ”¥
sub ðŸ”¥ 111

Although not a one-liner, it is still elegant. We map each 1 to a ðŸ”¥, which then maps to 111. This visualization of multiplication is very appealing.

What about exponentiation? Here's how to calculate 2^x. The intuition is to keep doubling a number starting from 1 and decrementing the input until only the former number remains.

sub ^ ðŸ”¥                        # Introduce ðŸ”¥, which will multiply to get 2^x
repeat till no change:
    replace ðŸ”¥1 ðŸ”¥              # decrement the number
    repeat till no change:     # if no number is left, replace ðŸ”¥ with 'S'
        replace ðŸ”¥$ S
        replace ðŸ”¥S SS
    replace ðŸ”¥ ðŸ”¥ðŸ”¥             # double ðŸ”¥!
replace S 1                     # final fix

Although there is a double repeat, the program remains intuitive. Without the cheat, the program would be slightly more complex.

I hope that the examples above have convinced you that what a Turing machine accomplishes in a lot of quadruples can often be expressed concisely in the string substitution model.

In conclusion, the model of computation using substitution and the "repeat till no change" operator allows us to express programs in a more concise way. In contrast to the standard approach of creating programming languages, which relies on adding many primitives to achieve conciseness, our model of computation works with just two primitives. By demonstrating the Turing completeness of this model of computation, we can boldly claim that something as fundamental as substitution is also very powerfulâ€”it might be all you need if you're open to cycling through your instructions repeatedly.

GitHub: mayankkamboj47@gmail.com
